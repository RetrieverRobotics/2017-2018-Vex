#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotL,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    swingPot,       sensorPotentiometer)
#pragma config(Sensor, in6,    armPotR,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  driveLEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  driveREnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           liftBL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftR,         tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           driveR,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           liftTL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mogo,          tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"

///////////////////////////////////////////////////////////////////////////////////
// PRE AUTON
///////////////////////////////////////////////////////////////////////////////////

void pre_auton(){

	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = true;

	clearDebugStream();
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "yeet");
	bLCDBacklight = true;
	short nLCDButtons_last = 0;
	const int numAutons = 3;
	string selectionString[numAutons] = {"Default", "Blue Preloads", "Red Preloads"};

	// only run if a button is pushed to prevent hanging up in a reset
	if(nLCDButtons > 0){
		displayLCDCenteredString(0, "Auton Selection");
		displayLCDCenteredString(1, "Activated");
		//wait for button release
		while(nLCDButtons > 0)
			wait1Msec(10);

		while(nLCDButtons != CENTER_LCD){
			if			(nLCDButtons == RIGHT_LCD && nLCDButtons_last != RIGHT_LCD)	autonSelection++;
			else if	(nLCDButtons == LEFT_LCD 	&& nLCDButtons_last != LEFT_LCD)	autonSelection--;

			if			(autonSelection >= numAutons) autonSelection = numAutons - 1;
			else if (autonSelection < 0) 					autonSelection = 0;
			displayLCDCenteredString(1,selectionString[autonSelection]); // display the selected zone

			nLCDButtons_last = nLCDButtons;
			wait1Msec(10);
		}//end while

		clearLCDLine(0);
		clearLCDLine(1);
		//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
		displayLCDCenteredString(0,"Init Calibration");
		displayLCDCenteredString(1,"Do not move bot");
		wait1Msec(1000);
		displayLCDCenteredString(0,"Calibrating...");
		SensorType[gyro] = sensorNone;
		wait1Msec(10);
		SensorType[gyro] = sensorGyro;
		wait1Msec(1300);
		//Adjust SensorScale to correct the scaling for your gyro
		SensorScale[gyro] = 138.5;//138.85;//138;
		clearLCDLine(0);
		clearLCDLine(1);
	}//end buttons > 0

	initPIDVars();
	displayLCDCenteredString(0,"RReady");
	bLCDBacklight = false;
}//END pre_auton

///////////////////////////////////////////////////////////////////////////////////
// AUTONOMOUS
///////////////////////////////////////////////////////////////////////////////////

task autonomous(){
	writeDebugStreamLine("auton");
	//zero encoders
	SensorValue[driveREnc] = 0;
	SensorValue[driveLEnc]	= 0;
	clearTimer(T1);

	// Blue preloads auton
	if(true){//autonSelection == BLUE_PRELOAD){//make separate function or file
		startingRotationOffset = 0; // facing positive x towards mogo
		SensorValue[claw] = CLAW_CLOSE;
		// startTask(coordinateMonitoring);
		armPID.target = ARM_SCHMEDIUM;
		startTask(armPIDTask);
		gyroPID.target = 0;
		startTask(drivePIDTask);
		swingPID.target = SWING_IN;
		startTask(swingPIDTask);

		//raise arm and put out mobile goal thing all while driving forward
		//arm already rising
		driveIncremental(48); // forward 48 inches
		wait1Msec(300);
		extendMogo();

		waitForPID(drivePID);

		//once at destination, pick up mobile goal
		intakeMogo();

		//drive back to loading station (line sensor?) while dropping preload
		driveIncremental(-12); // backward 12 inches
		//armPID.target = STARTING_HEIGHT; // lower arm to place cone

		waitForPID(drivePID);
		waitForPID(armPID);

		// drop cone
		SensorValue[claw] = CLAW_OPEN;

		//turn 90 towards preloader
		turnAbsolute(-90);

		//arm to loading height and drive forward
		armPID.target = ARM_PRELOAD_HEIGHT;
		swingPID.target = SWING_90;

		// turn drive PIDs off and give a basic constant power to slam wall
		drivePIDsOn(false);
		tankDrive(127, 127);
		wait1Msec(700);
		drivePIDsOn(true);

		//drive back 6 inches?

		//swing to cone loading height, claw, swing to drop height, release claw
		// do the first few runs until arm differential is needed
		for(int i = 0; i < 2; i++){
			swingPID.target = SWING_OUT;
			waitForPID(swingPID);
			wait1Msec(200); // insert reasonable wait time for humans to place cone
			SensorValue[claw] = CLAW_CLOSE;

			swingPID.target = SWING_IN;
			waitForPID(swingPID);
			SensorValue[claw] = CLAW_OPEN;
		}


		// repeat 13x plus 1 extra for a total of 14; add the arm += Cone_Differential
		for(int i = 0; i < 13; i++){
			swingPID.target = SWING_OUT;
			armPID.target = ARM_PRELOAD_HEIGHT;
			waitForPID(swingPID);
			waitForPID(armPID);
			wait1Msec(200); // insert reasonable wait time for humans to place cone
			SensorValue[claw] = CLAW_CLOSE;

			// TODO: make function that converts 2.5 inches to arm pot ticks
			armPID.target = ARM_PRELOAD_HEIGHT + (2.5 * i); // add 2.5 inches each go
			// wait until arm a specific distance from target
			//while(fabs(armPID.target - armPID.input) < SWING_ACTIVATE_ON_ARM_VAL);
			swingPID.target = SWING_IN;
			waitForPID(swingPID);
			waitForPID(armPID);
			SensorValue[claw] = CLAW_OPEN;
		}

		//drive back and finesse some points
	}
}

///////////////////////////////////////////////////////////////////////////////////
// USERCONTROL
///////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	writeDebugStreamLine("usrctrl");

	//armPID.target = 2000;//getArmHeight() / 2;
	//startTask(usrCtrlArmPID);

	//driveIncremental(12);
	//drivePID.target = 300;
	//gyroPID.target = 0;
	//gyroPID.target = -900;
	//startTask(drivePIDTask);
	//startTask(autonomous);

	//armPID.target = 2000;//getArmHeight() / 2;
	//startTask(armPIDTask);
	//waitForPID(armPID);
	//while(true){ wait1Msec(1000); } // for testing code above here

	clearTimer(T1);
	SensorValue[driveLEnc] = 0;
	SensorValue[driveREnc] = 0;
	bool bSwingManual = true;
	bool bSwingToggle = true;
	int leftDrive, rightDrive;
	string displayString;

	armPID.target = getArmHeight() / 2;
	// everything for the lift in usrctrl is handled in this task
	startTask(usrCtrlArmPID);

	// everything for the drive in usrctrl handled in this task.
	startTask(driveSlew);

	swingPID.target = SensorValue[swingPot];
	startTask(swingPIDTask);

	while ("Kent is driving"){
		if("we haven't won yet")
			smackVcat();

		// Display battery level
		clearLCDLine(0);
		clearLCDLine(1);
		sprintf(displayString, "Main: %2.2fV", nAvgBatteryLevel/1000.);
		displayLCDCenteredString(0, displayString);
		sprintf(displayString, "Backup: %2.2fV", BackupBatteryLevel/1000.);
		displayLCDCenteredString(1, displayString);

		//--------------------------------------------------------------------------------
		// Swing
		//--------------------------------------------------------------------------------

		//switch between manual and PID for swing on 8L
		if(vexRT[Btn8L]){
			if(bSwingToggle){
				bSwingManual = !bSwingManual;
				bSwingToggle = false;
			}
		}
		else{
			bSwingManual = true;
		}

		// if manual control is selected
		if(bSwingManual){
			swingPID.enabled = false;
			// swing in on 8D
			if(vexRT[Btn8D]){
				motor[swing] = 127;
			}
			// swing out on 8U
			else if(vexRT[Btn8U]){
				motor[swing] = -127;
			}
			else{
				motor[swing] = 0;
			}
		}
		// otherwise use PID control
		else{
			swingPID.enabled = true;
			// in on 8D
			if(vexRT[Btn8D]){
				swingPID.target = SWING_IN;
			}
			// out on 8U
			else if(vexRT[Btn8U]){
				swingPID.target = SWING_OUT;
			}
			// 90 on 8R
			else if(vexRT[Btn8R]){
				swingPID.target = SWING_90;
			}
		}

		//--------------------------------------------------------------------------------
		// Claw
		//--------------------------------------------------------------------------------

		// close on 6U
		if(vexRT[Btn6U]){
			SensorValue[claw] = CLAW_CLOSE;
		}
		// open on 6D
		else if(vexRT[Btn6D]){
			SensorValue[claw] = CLAW_OPEN;
		}

		//--------------------------------------------------------------------------------
		// Mogo
		//--------------------------------------------------------------------------------

		// if arm is below a certain height, dont use mogo
		if( getArmHeight() > ARM_BLOCK_MOGO ){
			// in on 7D
			if(vexRT[Btn7D]){
				motor[mogo] = 127;
			}
			//out on 7U
			else if(vexRT[Btn7U]){
				motor[mogo] = -127;
			}
			else{
				motor[mogo] = 0;
			}
		}
		else{
			motor[mogo] = 0;
		}

		wait1Msec(20);

	}//END while()
}//END usercontrol()
