#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotL,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    swingPot,       sensorPotentiometer)
#pragma config(Sensor, in6,    armPotR,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  driveLEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  driveREnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           liftBL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftR,         tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           driveR,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           liftTL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mogo,          tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"

///////////////////////////////////////////////////////////////////////////////////
// PRE AUTON
///////////////////////////////////////////////////////////////////////////////////

void pre_auton(){

	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = true;

	clearDebugStream();
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "yeet");
	bLCDBacklight = true;
	short nLCDButtons_last = 0;
	const int numAutons = 3;
	string selectionString[numAutons] = {"Default", "Blue Preloads", "Red Preloads"};

	// only run if a button is pushed to prevent hanging up in a reset
	if(nLCDButtons > 0){
		displayLCDCenteredString(0, "Auton Selection");
		displayLCDCenteredString(1, "Activated");
		//wait for button release
		while(nLCDButtons > 0)
			wait1Msec(10);

		while(nLCDButtons != CENTER_LCD){
			if			(nLCDButtons == RIGHT_LCD && nLCDButtons_last != RIGHT_LCD)	autonSelection++;
			else if	(nLCDButtons == LEFT_LCD 	&& nLCDButtons_last != LEFT_LCD)	autonSelection--;

			if			(autonSelection >= numAutons) autonSelection = numAutons - 1;
			else if (autonSelection < 0) 					autonSelection = 0;
			displayLCDCenteredString(1,selectionString[autonSelection]); // display the selected zone

			nLCDButtons_last = nLCDButtons;
			wait1Msec(10);
		}//end while

		clearLCDLine(0);
		clearLCDLine(1);
		//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
		displayLCDCenteredString(0,"Init Calibration");
		displayLCDCenteredString(1,"Do not move bot");
		wait1Msec(1000);
		displayLCDCenteredString(0,"Calibrating...");
		SensorType[gyro] = sensorNone;
		wait1Msec(10);
		SensorType[gyro] = sensorGyro;
		wait1Msec(1300);
		//Adjust SensorScale to correct the scaling for your gyro
		SensorScale[gyro] = 138.5;//138.85;//138;
		clearLCDLine(0);
		clearLCDLine(1);
	}//end buttons > 0

	initPIDVars();
	displayLCDCenteredString(0,"RReady");
	bLCDBacklight = false;
}//END pre_auton

///////////////////////////////////////////////////////////////////////////////////
// AUTONOMOUS
///////////////////////////////////////////////////////////////////////////////////

//skills; red side facing mogo although it might not matter
task autonomous(){
	writeDebugStreamLine("auton - skills");

	int oldDrive;

	clearTimer(T1);
	SensorValue[driveREnc] = 0;//zero encoders
	SensorValue[driveLEnc] = 0;
	startingRotationOffset = 0; // facing positive x towards mogo

	SensorValue[claw] = CLAW_CLOSE;
	armPID.target 		= ARM_SCHMEDIUM;
	gyroPID.target 		= 0;
	swingPID.target 	= SWING_IN;
	startTask(armPIDTask);
	startTask(drivePIDTask);
	startTask(swingPIDTask);

	// mogo 1
	// drive to 1st mogo
	driveIncremental(48);
	wait1Msec(300);
	extendMogo();
	waitForPID(drivePID);
	// grab 1st mogo and drop it off
	intakemogo();
	driveIncremental(-48); // drive backwards towards start
	waitForPID(drivePID);
	swingTurnRight(-135);
	waitForPID(gyroPID);
	// slam reset on the pipe
	tardDrive(127,127,1000);
	extendMogo();
	// tardDrive(-127,-127,300);
	driveIncremental(-4); // drive back enough to release mogo
	waitForPID(drivePID);
	intakeMogo();

	// mogo 2
	driveIncremental(-24); // cross pipe
	waitForPID(drivePID);
	swingTurnRight(45); // swing turn 180 degrees towards next mogo
	extendMogo();
	waitForPID(gyroPID);
	driveIncremental(24);
	waitForPID(drivePID);
	intakeMogo(); // pick up next mogo
	// turn around and drop off
	pointTurn(-135);
	waitForPID(gyroPID);
	driveIncremental(36);
	extendmogo();
	driveIncremental(-5);
	waitForPID(drivePID);
	intakeMogo();

  // mogo 3
	pointTurn(45); // face next mogo
	extendMogo();
	waitForPID(gyroPID);
	oldDrive = drivePID.input;
	driveIncremental(140); // go all the way across the field
	// wait for mogo halfway
	while(DRIVE_TPI*(drivePID.input-oldDrive) <  80) wait1Msec(drivePID.loopTime);
	intakeMogo();
	waitForPID(drivePID);


	/* bad
	driveIncremental(-24);
	waitForPID(drivePID);
	swingTurnRight(-135);
	waitForPID(gyroPID);
	// slam reset on the pipe
	tardDrive(127,127,1000);
	extendMogo();
	driveIncremental(-4); // drive back enough to release mogo
	waitForPID(drivePID);
	intakeMogo();


	// mogo 3
	driveIncremental(-24); // cross pipe
	waitForPID(drivePID);
	swingTurnLeft(-315); // swing turn 180 degrees towards next mogo
	extendMogo();
	waitForPID(gyroPID);
	driveIncremental(24);
	waitForPID(drivePID);
	intakeMogo();

	//back up and drop off
	driveIncremental(-24);
	waitForPID(drivePID);
	swingTurnLeft(-135);
	waitForPID(gyroPID);
	// slam reset on the pipe
	tardDrive(127,127,1000);
	extendMogo();
	driveIncremental(-4); // drive back enough to release mogo
	waitForPID(drivePID);
	intakeMogo();

  // mogo 4
	driveIncremental(-24); // cross pipe
	waitForPID(drivePID);
	swingTurnLeft(-315); // swing turn 180 degrees towards next mogo
	extendMogo();
	waitForPID(gyroPID);
	driveIncremental(24);
	waitForPID(drivePID);
	intakeMogo();
	*/

}

///////////////////////////////////////////////////////////////////////////////////
// USERCONTROL
///////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	writeDebugStreamLine("usrctrl");

	//armPID.target = 2000;//getArmHeight();
	//startTask(usrCtrlArmPID);

	//driveIncremental(12);
	//drivePID.target = 300;
	//gyroPID.target = 0;
	//gyroPID.target = -900;
	//startTask(drivePIDTask);
	//startTask(autonomous);

	//armPID.target = 2000;//getArmHeight();
	//startTask(armPIDTask);
	//waitForPID(armPID);
	//while(true){ wait1Msec(1000); } // for testing code above here

	clearTimer(T1);
	SensorValue[driveLEnc] = 0;
	SensorValue[driveREnc] = 0;
	bool bSwingManual = true;
	bool bSwingToggle = true;
	string displayString;

	armPID.target = getArmHeight();
	// everything for the lift in usrctrl is handled in this task
	startTask(usrCtrlArmPID);

	// everything for the drive in usrctrl handled in this task.
	startTask(driveSlew);

	swingPID.target = SensorValue[swingPot];
	startTask(swingPIDTask);

	while ("Kent is driving"){
		if("we haven't won yet")
			smackVcat();

		// Display battery level
		clearLCDLine(0);
		clearLCDLine(1);
		sprintf(displayString, "Main: %2.2fV", nAvgBatteryLevel/1000.);
		displayLCDCenteredString(0, displayString);
		sprintf(displayString, "Backup: %2.2fV", BackupBatteryLevel/1000.);
		displayLCDCenteredString(1, displayString);

		//--------------------------------------------------------------------------------
		// Swing
		//--------------------------------------------------------------------------------

		//switch between manual and PID for swing on 8L
		if(vexRT[Btn8L]){
			if(bSwingToggle){
				bSwingManual = !bSwingManual;
				bSwingToggle = false;
			}
		}
		else{
			bSwingManual = true;
		}

		// if manual control is selected
		if(bSwingManual){
			swingPID.enabled = false;
			// swing in on 8D
			if(vexRT[Btn8D]){
				motor[swing] = 127;
			}
			// swing out on 8U
			else if(vexRT[Btn8U]){
				motor[swing] = -127;
			}
			else{
				motor[swing] = 0;
			}
		}
		// otherwise use PID control
		else{
			swingPID.enabled = true;
			// in on 8D
			if(vexRT[Btn8D]){
				swingPID.target = SWING_IN;
			}
			// out on 8U
			else if(vexRT[Btn8U]){
				swingPID.target = SWING_OUT;
			}
			// 90 on 8R
			else if(vexRT[Btn8R]){
				swingPID.target = SWING_90;
			}
		}

		//--------------------------------------------------------------------------------
		// Claw
		//--------------------------------------------------------------------------------

		// close on 6U
		if(vexRT[Btn6U]){
			SensorValue[claw] = CLAW_CLOSE;
		}
		// open on 6D
		else if(vexRT[Btn6D]){
			SensorValue[claw] = CLAW_OPEN;
		}

		//--------------------------------------------------------------------------------
		// Mogo
		//--------------------------------------------------------------------------------

		// if arm is below a certain height, dont use mogo
		if( getArmHeight() > ARM_BLOCK_MOGO ){
			// in on 7D
			if(vexRT[Btn7D]){
				motor[mogo] = 127;
			}
			//out on 7U
			else if(vexRT[Btn7U]){
				motor[mogo] = -127;
			}
			else{
				motor[mogo] = 0;
			}
		}
		else{
			motor[mogo] = 0;
		}

		wait1Msec(20);

	}//END while()
}//END usercontrol()
