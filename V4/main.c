	#pragma config(UserModel, "ports.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

#pragma debuggerWindows("debugStream");
#pragma debuggerWindows("vexCompetitionControl");
#pragma debuggerWindows("VexLCD");

//Main competition background code...do not modify!
// #include "Vex_Competition_Includes.c"
#warning "main"
#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"

///////////////////////////////////////////////////////////////////////////////////
// PRE AUTON
///////////////////////////////////////////////////////////////////////////////////

void pre_auton(){

	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = true;
	clearDebugStream();
	// clearTimer(T1);
	// startTask(auton);
	// startTask(usercontrol);

	// string displayString;
	// sprintf(displayString, "%i\n%i\n%i", vrDisabled, vrAutonomousMode, vrCompetitionSwitch);
	// writeDebugStreamLine(displayString);

#include "pre_auton.c"
}//END pre_auton

///////////////////////////////////////////////////////////////////////////////////
// AUTONOMOUS
///////////////////////////////////////////////////////////////////////////////////

task autonomous(){
	writeDebugStreamLine("auton");

	displayLCDCenteredString(0,"Calibrating...");
  SensorType[gyro] = sensorNone;
  wait1Msec(10);
  SensorType[gyro] = sensorGyro;
  wait1Msec(1300);
  //Adjust SensorScale to correct the scaling for your gyro
  SensorScale[gyro] = 138.5;//138.85;//138;
  clearLCDLine(0);
  clearLCDLine(1);

	startingRotationOffset = 0; // facing positive x towards mogo
  SensorValue[claw] = CLAW_CLOSE;
	armPID.target 		= ARM_PRELOAD_HEIGHT;
	gyroPID.target 		= 0;
	swingPID.target 	= SWING_IN;
	startTask(armPIDTask);
	startTask(drivePIDTask);
	startTask(swingPIDTask);
	int newHeight;
	waitForPID(armPID);
	wait1Msec(200);

	// swing to cone loading height, grab, swing to drop height, release
  // do the first few runs until arm differential is needed
  for(int i = 0; i < 2; i++){
    wait1Msec(AUTON_RELOAD_TIME);
    SensorValue[claw] = CLAW_CLOSE;

    swingPID.target = SWING_IN;
    waitForPID(swingPID);
    SensorValue[claw] = CLAW_OPEN;
    wait1Msec(CLAW_OPEN_TIME);
    swingPID.target = SWING_OUT;
    waitForPID(swingPID);
  }


  // repeat 13x plus 1 extra for a total of 14
  for(int i = 0; i < AUTON_STACK_COUNT; i++){
    wait1Msec(AUTON_RELOAD_TIME);
    SensorValue[claw] = CLAW_CLOSE;

    // add 2.5 inches each go
    newHeight = ARM_PRELOAD_HEIGHT + (ARM_TICKS_PER_INCH * INCHES_PER_CONE * i);
    setArmHeight(newHeight);
    // wait until arm a specific distance from target
    // while the error of the arm is bigger than SWING_ACTIVATION_DIST
    while(fabs(armPID.target - getArmHeight()) > SWING_ACTIVATION_DIST)
      wait1Msec(10);

    swingPID.target = SWING_IN;
    waitForPID(armPID);
    waitForPID(swingPID);
    wait1Msec(100);
    //tard down
    tardLift(-127);
    wait1Msec(100);
    tardLift();

    // stop here on the last one
    if(i == AUTON_STACK_COUNT)
      break;

    SensorValue[claw] = CLAW_OPEN;
    wait1Msec(CLAW_OPEN_TIME);
    setArmHeight(newHeight + ARM_CLEAR_CONE); // clear the cone
    swingPID.target = SWING_OUT;

    // wait for swing to clear cone
    while (SensorValue[swingPot] > SWING_CLEAR_CONE)
      wait1Msec(10);

    setArmHeight(ARM_PRELOAD_HEIGHT);
    waitForPID(swingPID);
    waitForPID(armPID);
    wait1Msec(100);
  }

	while(true){wait1Msec(1000);}

	startTask(displayTime);
	//#include "auton.c"
	stopTask(displayTime);
}

///////////////////////////////////////////////////////////////////////////////////
// USERCONTROL
///////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	writeDebugStreamLine("usrctrl");

	//motor[liftR] = 60;
	//motor[driveR2] = 60;
	//pointTurn(180);
	//startTask(drivePIDTask);

	//swingPID.target = SWING_90;
	//startTask(swingPIDTask);

	//setArmHeight(500);
	//startTask(armPIDTask);

	//motor[liftL] = 60;
	//while(true){
	//	SensorValue[claw] = 1;
	//	wait1Msec(500);
	//	SensorValue[claw] = 0;
	//	wait1Msec(500);
	//}

//#define lul 15//50

//	while(true) {
//		lolkekxd:
//		if(vexRT[Btn8D]){
//		SensorValue[claw] = 1;
//		wait1Msec(lul);
//		if(vexRT[Btn8D] == 0){
//			goto lolkekxd;
//		}
//		SensorValue[claw] = 0;
//		wait1Msec(lul);
//		}

//	}

	//motor[liftL] = 127;

	//startingRotationOffset = 0; // facing positive x towards mogo
 // SensorValue[claw] = CLAW_CLOSE;
	//armPID.target 		= ARM_SCHMEDIUM;
	//gyroPID.target 		= 0;
	//swingPID.target 	= SWING_IN;
	//driveIncremental(0);
	//startTask(armPIDTask);
	//startTask(drivePIDTask);
	//startTask(swingPIDTask);

	////driveIncremental(12);
	//pointTurn(0);

	//while(true){wait1Msec(1000);}
	// while(true){
	//// 	motor[driveL1] = 69;
	//// 	writeDebugStreamLine("%i", vexRT[Ch3]);
	// 	wait1Msec(10);
	// } // for testing code above here

	// check if second controller is connected
	if (nVexRCReceiveState & vrXmit2) {
		#include "usercontrol-2Controller.c"
	}
	else {
		#include "usercontrol-singleController.c"
	}

	if("we haven't won yet")
		smackVcat();

}//END usercontrol()
