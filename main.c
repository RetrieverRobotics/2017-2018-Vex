#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotL,        sensorPotentiometer)
#pragma config(Sensor, in2,    armPotR,        sensorPotentiometer)
#pragma config(Sensor, in3,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    swingPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           driveL,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           liftBl,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftTr,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveR,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           liftTl,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftBr,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mogo,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

///////////////////////////////////////
// Global variables
///////////////////////////////////////

typedef struct PIDStruct{
	bool debug;
	bool enabled;
	float target;
	float previousError;
	float integral;
	int 	output;
	int 	input;

	float Kp;
	float Ki;
	float Kd;

	float integralLimit;
	float integralActiveZone;

	int 	loopTime;

}PIDStruct;

PIDStruct driveLPID;
PIDStruct driveRPID;
PIDStruct gyroPID;
PIDStruct armPID;
PIDStruct armCrossCouplePID;
PIDStruct mogoPID;
PIDStruct swingPID;
#define MAX_PID_VARS 7

// array storing pointers to the PID variables for ease of access in PID functions
PIDStruct *PIDVars[MAX_PID_VARS] = {&driveLPID, &driveRPID, &gyroPID, &armPID, &armCrossCouplePID, &mogoPID, &swingPID};

int autonSelection = 0;
float globalXPos = 0;
float globalYPos = 0;
float startingRotationOffset = 0; // 0 is facing positive y

#define LEFT_LCD 1
#define CENTER_LCD 2
#define RIGHT_LCD 4
#define GET_HEADING() ((SensorValue[gyro] / 10) + 90 + startingRotationOffset)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"


void pre_auton()
{
	initPIDVars();
	//bDisplayCompetitionStatusOnLcd = false;
	//bStopTasksBetweenModes = true;

	//clearDebugStream();

	//bLCDBacklight = true;
	//short nLCDButtons_last = 0;
	//const int numAutons = 2;
	//string selectionString[numAutons] = {"sadfdefault", "eyb0ss"};

	//// only run if a button is pushed to prevent hanging up in a reset
	//if(nLCDButtons > 0){
	//	displayLCDCenteredString(0, "Auton Selection");
	//	displayLCDCenteredString(1, "Activated");
	//	//wait for button release
	//	while(nLCDButtons > 0)
	//		wait1Msec(10);

	//	while(nLCDButtons != CENTER_LCD){
	//		if			(nLCDButtons == RIGHT_LCD && nLCDButtons_last != RIGHT_LCD)	autonSelection++;
	//		else if	(nLCDButtons == LEFT_LCD 	&& nLCDButtons_last != LEFT_LCD)	autonSelection--;

	//		if			(autonSelection >= numAutons) autonSelection = numAutons - 1;
	//		else if (autonSelection < 0) 					autonSelection = 0;
	//		displayLCDCenteredString(1,selectionString[autonSelection]); // display the selected zone

	//		nLCDButtons_last = nLCDButtons;
	//		wait1Msec(10);
	//	}
	//}

	//initPIDVars();
	////Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	////displayLCDCenteredString(0,"Init Calibration");
	////wait1Msec(1000);
	////displayLCDCenteredString(0,"Calibrating...");
	////SensorType[gyro] = sensorNone;
	////wait1Msec(10);
	////SensorType[gyro] = sensorGyro;
	////wait1Msec(1300);
	//////Adjust SensorScale to correct the scaling for your gyro
	////SensorScale[gyro] = 138;
	//displayLCDCenteredString(0,"RReady");
	//bLCDBacklight = false;
}//END pre_auton


task autonomous()
{
	//zeroOdomSensors(){
	//SensorValue[gyro] 						= 0;//zero gyro
	//nMotorEncoder[driveBackRight] = 0;//zero encoders
	//nMotorEncoder[driveBackLeft]	= 0;

	// Remove this function call once you have "real" code.
	AutonomousCodePlaceholderForTesting();
}


task usercontrol()
{
	//motor[liftTl] = 50;
	//motor[liftTr] = 50;
	//motor[liftBl] = 50;
	//motor[liftBr] = 50;
	//setLift(60);
armCrossCouplePID.enabled = true;
	startTask(usrCtrlArmPID);
	while (true)
	{
		//motor[liftTl] = 50;
		//motor[liftTr] = 50;
		//motor[liftBl] = 50;
		//motor[liftBr] = 50;
		//writeDebugStream("%f\t%f\n", SensorValue[armPotL], SensorValue[armPotR]);
		//--------------------------------------------------------------------------------
		// Drive
		//--------------------------------------------------------------------------------

		// tank drive
		motor[driveL] = vexRT[Ch3];
		motor[driveR] = vexRT[Ch2];

		//--------------------------------------------------------------------------------
		// Lift
		//--------------------------------------------------------------------------------

		// up on 5U
		//if(vexRT[Btn5U]){
		//	setLift(50);
		//}
		//// down on 5D
		//else if(vexRT[Btn5D]){
		//	setLift(-50);
		//}
		//else{
		//	setLift(0);
		//}

		//--------------------------------------------------------------------------------
		// Swing
		//--------------------------------------------------------------------------------

		// up on 8U
		if(vexRT[Btn8U]){
			motor[swing] = 127;
		}
		// down on 8D
		else if(vexRT[Btn8D]){
			motor[swing] = -127;
		}
		else{
			motor[swing] = 0;
		}

		//--------------------------------------------------------------------------------
		// Claw
		//--------------------------------------------------------------------------------

		// close on 6U
		if(vexRT[Btn6U]){
			SensorValue[claw] = 1;
		}
		// open on 6D
		else if(vexRT[Btn6D]){
			SensorValue[claw] = 0;
		}

		//--------------------------------------------------------------------------------
		// Mogo
		//--------------------------------------------------------------------------------

		// in on 7U
		if(vexRT[Btn7U]){
			motor[mogo] = 127;
		}
		//out on 7D
		else if(vexRT[Btn7D]){
			motor[mogo] = -127;
		}
		else{
			motor[mogo] = 0;
		}

		wait1Msec(10);
	}//END while()
}//END usercontrol()
