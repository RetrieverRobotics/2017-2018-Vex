#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotL,        sensorPotentiometer)
#pragma config(Sensor, in2,    armPotR,        sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    swingPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           liftTr,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           liftBl,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           driveL,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveR,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           liftTl,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftBr,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mogo,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

///////////////////////////////////////
// Global variables
///////////////////////////////////////

typedef struct PIDStruct{
	bool debug;
	bool enabled;
	float target;
	float previousError;
	float integral;
	int 	output;
	float input;
	float errorThreshold;
	float speedThreshold;

	float Kp;
	float Ki;
	float Kd;
	float integralLimit;
	float integralActiveZone;

	int 	loopTime;

}PIDStruct;

PIDStruct driveLPID;
PIDStruct driveRPID;
PIDStruct gyroPID;
PIDStruct armPID;
PIDStruct armCrossCouplePID;
PIDStruct mogoPID;
PIDStruct swingPID;
#define MAX_PID_VARS 7

int autonSelection = 0;
float globalXPos = 0;
float globalYPos = 0;
float startingRotationOffset = 0; // 0 is facing positive y

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"

//void pre_auton(){
//	clearDebugStream();
//	bStopTasksBetweenModes = true;
//	writeDebugStreamLine("here");
//}

void pre_auton()
{

	//bDisplayCompetitionStatusOnLcd = false;
	//bStopTasksBetweenModes = true;

	clearDebugStream();
	bLCDBacklight = true;
	short nLCDButtons_last = 0;
	const int numAutons = 2;
	string selectionString[numAutons] = {"777default", "eyb0ss"};

	// only run if a button is pushed to prevent hanging up in a reset
	if(nLCDButtons > 0){
		displayLCDCenteredString(0, "Auton Selection");
		displayLCDCenteredString(1, "Activated");
		//wait for button release
		while(nLCDButtons > 0)
			wait1Msec(10);

		while(nLCDButtons != CENTER_LCD){
			if			(nLCDButtons == RIGHT_LCD && nLCDButtons_last != RIGHT_LCD)	autonSelection++;
			else if	(nLCDButtons == LEFT_LCD 	&& nLCDButtons_last != LEFT_LCD)	autonSelection--;

			if			(autonSelection >= numAutons) autonSelection = numAutons - 1;
			else if (autonSelection < 0) 					autonSelection = 0;
			displayLCDCenteredString(1,selectionString[autonSelection]); // display the selected zone

			nLCDButtons_last = nLCDButtons;
			wait1Msec(10);
		}//end while

		//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
		displayLCDCenteredString(0,"Init Calibration");
		wait1Msec(1000);
		displayLCDCenteredString(0,"Calibrating...");
		SensorType[gyro] = sensorNone;
		wait1Msec(10);
		SensorType[gyro] = sensorGyro;
		wait1Msec(1300);
		//Adjust SensorScale to correct the scaling for your gyro
		SensorScale[gyro] = 138;
	}//end buttons > 0

	initPIDVars();
	displayLCDCenteredString(0,"RReady");
	bLCDBacklight = false;
}//END pre_auton


task autonomous()
{
	//zero encoders
	nMotorEncoder[driveR] = 0;
	nMotorEncoder[driveL]	= 0;

	//startTask(coordinateMonitoring);
	////armPID.target = STARTING_HEIGHT;
	//startTask(armPIDTask);
	//startTask(drivePIDTask);
	clearTimer(T1);

	// Blue preloads auton
	if(autonSelection == BLUE_PRELOAD){//make separate function
		SensorValue[claw] = CLAW_CLOSE;
		startingRotationOffset = -90; // facing positive x towards mogo

		// startTask(coordinateMonitoring);
		armPID.target = ARM_SCHMEDIUM;
		startTask(armPIDTask);
		startTask(drivePIDTask);
		swingPID.target = SWING_IN;
		startTask(swingPIDTask);

		//raise arm and put out mobile goal thing all while driving forward
		//arm already rising
		driveIncremental(48); // forward 48 inches
		extendMogo();

		waitUntilPIDAtTarget(driveLPID);
		waitUntilPIDAtTarget(driveRPID);

		//once at destination, pick up mobile goal
		intakeMogo();

		//drive back to loading station (line sensor?) while dropping preload
		driveIncremental(-12); // backward 12 inches
		//armPID.target = STARTING_HEIGHT; // lower arm to place cone

		waitUntilPIDAtTarget(driveLPID);
		waitUntilPIDAtTarget(driveRPID);
		waitUntilPIDAtTarget(armPID);

		// drop cone
		SensorValue[claw] = CLAW_OPEN;

		//turn 90 towards preloader
		turnAbsolute(-90);

		//arm to loading height and drive forward
		armPID.target = ARM_PRELOAD_HEIGHT;
		swingPID.target = SWING_90;

		// turn drive PIDs off and give a basic constant power to slam wall
		drivePIDsOn(false);
		motor[driveL] = 127;
		motor[driveR] = 127;
		wait1Msec(700);
		drivePIDsOn(true);

		//drive back 6 inches?

		//swing to cone loading height, claw, swing to drop height, release claw
		// do the first few runs until arm differential is needed
		for(int i = 0; i < 2; i++){
			swingPID.target = SWING_OUT;
			waitUntilPIDAtTarget(swingPID);
			wait1Msec(200); // insert reasonable wait time for humans to place cone
			SensorValue[claw] = CLAW_CLOSE;

			swingPID.target = SWING_IN;
			waitUntilPIDAtTarget(swingPID);
			SensorValue[claw] = CLAW_OPEN;
		}


		// repeat 13x plus 1 extra for a total of 14; add the arm += Cone_Differential
		for(int i = 0; i < 13; i++){
			swingPID.target = SWING_OUT;
			armPID.target = ARM_PRELOAD_HEIGHT;
			waitUntilPIDAtTarget(swingPID);
			waitUntilPIDAtTarget(armPID);
			wait1Msec(200); // insert reasonable wait time for humans to place cone
			SensorValue[claw] = CLAW_CLOSE;

			// TODO: make function that converts 2.5 inches to arm pot ticks
			armPID.target = ARM_PRELOAD_HEIGHT + (2.5 * i); // add 2.5 inches each go
			// wait until arm a specific distance from target
			//while(fabs(armPID.target - armPID.input) < SWING_ACTIVATE_ON_ARM_VAL);
			swingPID.target = SWING_IN;
			waitUntilPIDAtTarget(swingPID);
			waitUntilPIDAtTarget(armPID);
			SensorValue[claw] = CLAW_OPEN;
		}

		//drive back and finesse some points
	}
}


task usercontrol()
{
	clearTimer(T1);
	int timeKeked = 0;
	bool wasHereBefore = false;
	bool DaBaDeeDaBaDai = true;

	//motor[port10] = 127;
	//setLift(127);
	//motor[liftTr] = 127;
	//motor[liftBr] = 127;
	//wait1Msec(2000);

	//startTask(usrCtrlArmPID);

	armPID.target = SensorValue[armPotL];
	//startTask(armPIDTask);

	while ("Kent is driving")
	{
		if("we haven't won yet"){
			smackVcat();
			//--------------------------------------------------------------------------------
			// Drive
			//--------------------------------------------------------------------------------

			// tank drive
			//motor[driveL] = 127;
			//motor[driveR] = 127;
			motor[driveL] = vexRT[Ch3];
			motor[driveR] = vexRT[Ch2];

			//--------------------------------------------------------------------------------
			// Lift
			//--------------------------------------------------------------------------------

			// up on 5U
			if(vexRT[Btn5U]){
				armPID.enabled = false;
				setLift(127);
				wasHereBefore = false;
			}
			// down on 5D
			else if(vexRT[Btn5D]){
				armPID.enabled = false;
				setLift(-127);
				wasHereBefore = false;
			}
			else{
        // clear timer once immediately after button release
				if(!wasHereBefore){
					clearTimer(T1);
					wasHereBefore = true;
					DaBaDeeDaBaDai = true; // set up to turn on pid later
				}

				// set armPID target to current sensorValue only once after the desired time passes
				if(DaBaDeeDaBaDai && time1[T1] > 500){
					armPID.target = SensorValue[armPotL];
					armPID.enabled = true;
					DaBaDeeDaBaDai = false;
				}
			}

			//--------------------------------------------------------------------------------
			// Swing
			//--------------------------------------------------------------------------------

			// up on 8U
			if(vexRT[Btn8U]){
				//make swing in button
				//swingPID.target = SWING_IN;
				motor[swing] = 127;
			}
			// down on 8D
			else if(vexRT[Btn8D]){
				//make swing out button
				//swingPID.target = SWING_OUT;
				motor[swing] = -127;
			}
			else{
				//remove this
				motor[swing] = 0;
			}

			//--------------------------------------------------------------------------------
			// Claw
			//--------------------------------------------------------------------------------

			// close on 6U
			if(vexRT[Btn6U]){
				SensorValue[claw] = 1;
			}
			// open on 6D
			else if(vexRT[Btn6D]){
				SensorValue[claw] = 0;
			}

			//--------------------------------------------------------------------------------
			// Mogo
			//--------------------------------------------------------------------------------

			// in on 7U
			if(vexRT[Btn7U]){
				motor[mogo] = 127;
			}
			//out on 7D
			else if(vexRT[Btn7D]){
				motor[mogo] = -127;
			}
			else{
				motor[mogo] = 0;
			}

			wait1Msec(10);
		}

	}//END while()
}//END usercontrol()
