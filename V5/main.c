#pragma config(UserModel, "ports.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

#pragma debuggerWindows("debugStream");
#pragma debuggerWindows("vexCompetitionControl");
#pragma debuggerWindows("VexLCD");

//Main competition background code...do not modify!
// #include "Vex_Competition_Includes.c"
#warning "main"
#include "vex.c"
#include "declarations.c"
#include "variablesForKent.c"
#include "functions.c"

///////////////////////////////////////////////////////////////////////////////////
// PRE AUTON
///////////////////////////////////////////////////////////////////////////////////

void pre_auton(){

	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = true;
	clearDebugStream();
	// clearTimer(T1);
	// startTask(auton);
	// startTask(usercontrol);

	// string displayString;
	// sprintf(displayString, "%i\n%i\n%i", vrDisabled, vrAutonomousMode, vrCompetitionSwitch);
	// writeDebugStreamLine(displayString);

#include "pre_auton.c"
}//END pre_auton

///////////////////////////////////////////////////////////////////////////////////
// AUTONOMOUS
///////////////////////////////////////////////////////////////////////////////////

task autonomous(){
	writeDebugStreamLine("auton");
	//startTask(drivePIDTask);
	//SensorValue[claw] = CLAW_CLOSE;
	//swingPID.enabled = false;
	//tardLiftStraight(0);
	//startTask(swingPIDTask);
	//startTask(armPIDTask);
	////startingRotationOffset = 0;
	////pointTurn(720);
	////waitForPID(gyroPID);
	////driveIncremental(-6);


	//tardLiftStraight(-40);
	//motor[swing] = 40;
	//extendMogo();
	//motor[swing] = -40;
	//tardLiftStraight(0);
	//SensorValue[claw] = CLAW_OPEN;
	//wait1Msec(CLAW_OPEN_TIME);
	//motor[swing] = 0;

	//// tardDrive(-60,-60,300);
	//driveIncremental(-4); // drive back enough to release mogo
	//waitForPID(drivePID);

	//startingRotationOffset = 0;
	//pointTurn(-40);
 // writeDebugStreamLine("here2");
 // waitForPID(gyroPID);
 // writeDebugStreamLine("here1");
 // driveIncremental(-6);
 // //tardDriveStraight(-100);
 // //wait1Msec(100);
 // //tardDrive(0);
 // // driveIncremental(-6);
 //  waitForPID(drivePID);
 // writeDebugStreamLine("here");
 // pointTurn(-90);


	//while(1){wait1Msec(1000);}

	//displayLCDCenteredString(0,"Calibrating...");
 // SensorType[gyro] = sensorNone;
 // wait1Msec(10);
 // SensorType[gyro] = sensorGyro;
 // wait1Msec(1300);
 // //Adjust SensorScale to correct the scaling for your gyro
 // SensorScale[gyro] = 138.5;//138.85;//138;
 // clearLCDLine(0);
 // clearLCDLine(1);

	//startingRotationOffset = 0; // facing positive x towards mogo
 // SensorValue[claw] = CLAW_CLOSE;
	//setArmHeight(ARM_PRELOAD_HEIGHT);
	//gyroPID.target 		= 0;
	//swingPID.target 	= SWING_IN;
	//startTask(armPIDTask);
	//startTask(drivePIDTask);
	//startTask(swingPIDTask);
	//int newHeight;
	//waitForPID(armPID);
	//wait1Msec(200);

	bLCDBacklight = false;

	startTask(displayTime);
	#include "auton.c"
	stopTask(displayTime);
}

///////////////////////////////////////////////////////////////////////////////////
// USERCONTROL
///////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	writeDebugStreamLine("usrctrl");

	//motor[liftR] = 60;
	//motor[driveR2] = 60;
	//pointTurn(180);
	//startTask(drivePIDTask);

	//swingPID.target = SWING_90;
	//startTask(swingPIDTask);

	//setArmHeight(500);
	//startTask(armPIDTask);

	//motor[liftL] = 60;
	//while(true){
	//	SensorValue[claw] = 1;
	//	wait1Msec(500);
	//	SensorValue[claw] = 0;
	//	wait1Msec(500);
	//}

//#define lul1 12//15//50
//#define lul2 11//15//50
//#define lul3 10//15//50
//#define lul4 9//15//50
//#define lul5 8//15//50
//#define lul6 7//15//50
//#define lul7 6//15//50
//#define lul8 5//15//50

//	//while(true) {
//	//	if(vexRT[Btn7D]){
//	//		SensorValue[claw] = 1;
//	//		wait1Msec((vexRT[Ch2]+127)*20/255);
//	//		SensorValue[claw] = 0;
//	//		wait1Msec((vexRT[Ch2]+127)*20/255);
//	//	}

//	//}
//startTask(swingerino);

//	while(true) {

//		if(vexRT[Btn8D]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul1);
//			SensorValue[claw] = 0;
//			wait1Msec(lul1);
//		}
//		if(vexRT[Btn8R]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul2);
//			SensorValue[claw] = 0;
//			wait1Msec(lul2);
//		}
//		if(vexRT[Btn8U]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul3);
//			SensorValue[claw] = 0;
//			wait1Msec(lul3);
//		}
//		if(vexRT[Btn8L]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul4);
//			SensorValue[claw] = 0;
//			wait1Msec(lul4);
//		}


//		if(vexRT[Btn7D]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul5);
//			SensorValue[claw] = 0;
//			wait1Msec(lul5);
//		}
//		if(vexRT[Btn7R]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul6);
//			SensorValue[claw] = 0;
//			wait1Msec(lul6);
//		}
//		if(vexRT[Btn7U]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul7);
//			SensorValue[claw] = 0;
//			wait1Msec(lul7*2);
//		}
//		if(vexRT[Btn7L]){
//			SensorValue[claw] = 1;
//			wait1Msec(lul8);
//			SensorValue[claw] = 0;
//			wait1Msec(lul8);
//		}


//	}


	//motor[liftL] = 127;

	//startingRotationOffset = 0; // facing positive x towards mogo
 // SensorValue[claw] = CLAW_CLOSE;
	//armPID.target 		= ARM_SCHMEDIUM;
	//gyroPID.target 		= 0;
	//swingPID.target 	= SWING_IN;
	//driveIncremental(0);
	//startTask(armPIDTask);
	//startTask(drivePIDTask);
	//startTask(swingPIDTask);

	////driveIncremental(12);
	//pointTurn(0);

	//setArmHeight(500);
	//startTask(armPIDTask);
	//setArmHeight(1000);

	//while(true){wait1Msec(1000);}
	// while(true){
	//// 	motor[driveL1] = 69;
	//// 	writeDebugStreamLine("%i", vexRT[Ch3]);
	// 	wait1Msec(10);
	// } // for testing code above here

	// check if second controller is connected
	if (nVexRCReceiveState & vrXmit2) {
		#include "usercontrol-2Controller.c"
	}
	else {
		#include "usercontrol-singleController.c"
	}

	if("we haven't won yet")
		smackVcat();

}//END usercontrol()
